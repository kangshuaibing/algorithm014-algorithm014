# 第二周学习笔记

## 感想
算法训练营的第二周，除了把超哥课上讲到的题目做了一遍外，也在坚持每日一题。算下来平均每天才两道题，距离五毒神掌还是与差距的，下周开始要每天三题和画脑图。

## 切题四件套
1.Clarificatin  
2.pssiable solution --> ptimal(time & space)  
3.code   
4.test cases  
## 视频笔记

### 1.哈希表，映射，集合()
* 工程实践  
  1.电话簿  
  2.用户信息表  
  3.缓存(LRU Cache)
  4.键值对存储(Redis)

	Map:key-value对，key不重复
	Set:重复元素的集合
### 2.栈(Stack)，队列(Queue)
* 栈:先入后出，添加、删除皆为O(1)  
* 队列:先入先出，添加、删除皆为O(1)  
* 双端队列(deque:Double-End-Queue)  
* 优先队列(pritory queue)  
  1.插入O(1)  
  2.取出O(logN)-按照元素优先级  
  3.底层具体实现：堆(heap)、二叉搜索树(bst)、堆树(treap)

* 最近相关性-栈  
* 先来后到-队列  

### 3.堆（heap)和二叉堆的实现和特性
* heap:可以迅速找到一堆数中最大或者最小值的数据结构
根节点最大的堆叫做大顶堆或大根堆，根节点最小的叫做小顶堆或下根堆。
常见的堆有二叉堆、斐波拉契堆等  
大顶堆常见API:  
find-Max:O(1)  
delete-Max:O(logN)  
insert(create):O(logN) or O(1) 
* 二叉堆性质
通过完全二叉树实现（注意：不是二叉搜索树）  
二叉堆（大顶）满足下列性质：  
1.是一颗完全树  
2树中任意节点的值总是>=其子节点的值  

* 二叉堆实现细节
1.一般通过“数组”实现
2.假设“第一个元素”索引为0，则父节点和子节点的位置关系如下：  
（1）索引为i的左孩子节点索引是（2*i+1);  
（1）索引为i的右孩子节点索引是（2*i+1);  
（1）索引为i的父节点索引是floor((i-1)/2);  

* insert插入操作O(logN)-HeapifyUP
1.新元素先插入堆的尾部  
2.依次向上调整堆的结构（一直到根）

* delete max删除堆顶操作O(logN)-HeapifyUP
1.新元素先插入堆的顶部  
2.依次从根部向下调整整个堆的结构（一直到根尾）

注意：二叉堆是堆（优先队列priority_queue)的一种常见的简单的实现；但并不是最优的实现。

### 4.图的实现和特性
* 图的属性和分类
**图的属性
1.Graph(V,E)
2.V-vertex 点
度-入度和出度
点与点之间-是否连通
3.E-edge 边
有向和无向（单行线）
权重（边长）
**图的表示和分类
1.无向无权图
邻接矩阵（对角线对称）
邻接表
2.有向无权图
3.无向有权图
* 基于图相关的算法
DFS——递归写法
visited = set() #和树DFS最大的区别

BFS  
